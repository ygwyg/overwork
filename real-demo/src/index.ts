import { faker } from "@faker-js/faker";
import { format as formatSQL } from "sql-formatter";

export default {
  async fetch(request: Request, env: Record<string, any>): Promise<Response> {
    const url = new URL(request.url);

    if (url.pathname === "/pdf") return handlePdf(url, env);
    if (url.pathname === "/format-sql" && request.method === "POST") return handleSqlFormat(request, url);
    if (url.pathname === "/mock-data") return handleMockData(url);

    return Response.json({
      name: "overwork v0.3 demo",
      description: "3.8 MB of dependencies split into 3 service Workers via RPC. pdf-lib (class-based API), faker (nested namespaces), sql-formatter (flat functions) — all working.",
      total_bundle: "3.8 MB",
      main_worker: "~5 KB",
      endpoints: {
        "GET /pdf?title=Hello&body=World": "Generate a PDF (pdf-lib, 830 KB) — class-based API via RpcTarget",
        "POST /format-sql?dialect=postgresql": "Format SQL (sql-formatter, 548 KB) — flat function API",
        "GET /mock-data?count=5": "Generate fake users (@faker-js/faker, 2.8 MB) — nested namespace API",
      },
      try_it: [
        'curl https://devtools-api.design-engineering.workers.dev/pdf -o demo.pdf',
        'curl -X POST https://devtools-api.design-engineering.workers.dev/format-sql -d "select * from users where active=true"',
        'curl https://devtools-api.design-engineering.workers.dev/mock-data?count=3',
      ],
    }, { headers: { "content-type": "application/json" } });
  },
};

async function handlePdf(url: URL, env: Record<string, any>): Promise<Response> {
  const title = url.searchParams.get("title") ?? "Hello from overwork";
  const body = url.searchParams.get("body") ?? "This PDF was generated by a Cloudflare Worker using pdf-lib. The library (830 KB) runs in a separate service Worker, called via RPC.";

  const start = Date.now();
  const bytes = await env.PDF_LIB.generatePdf(title, body);
  const elapsed = Date.now() - start;

  return new Response(bytes, {
    headers: {
      "content-type": "application/pdf",
      "content-disposition": 'inline; filename="overwork-demo.pdf"',
      "x-generate-time-ms": String(elapsed),
      "x-split-via": "service-binding-rpc",
    },
  });
}

async function handleSqlFormat(request: Request, url: URL): Promise<Response> {
  const sql = await request.text();
  if (!sql.trim()) {
    return Response.json({ error: "Send SQL in the request body" }, { status: 400 });
  }

  const dialect = url.searchParams.get("dialect") ?? "postgresql";
  const start = Date.now();
  const formatted = await formatSQL(sql, { language: dialect, tabWidth: 2 });
  const elapsed = Date.now() - start;

  return new Response(formatted, {
    headers: {
      "content-type": "text/plain",
      "x-format-time-ms": String(elapsed),
      "x-dialect": dialect,
      "x-split-via": "service-binding-rpc",
    },
  });
}

async function handleMockData(url: URL): Promise<Response> {
  const count = Math.min(parseInt(url.searchParams.get("count") ?? "5", 10), 50);
  const start = Date.now();

  const users = [];
  for (let i = 0; i < count; i++) {
    users.push({
      id: await faker.string.uuid(),
      name: await faker.person.fullName(),
      email: await faker.internet.email(),
      company: await faker.company.name(),
      address: {
        street: await faker.location.streetAddress(),
        city: await faker.location.city(),
        country: await faker.location.country(),
      },
      avatar: await faker.image.avatar(),
      registeredAt: (await faker.date.past()).toISOString(),
    });
  }
  const elapsed = Date.now() - start;

  return Response.json(users, {
    headers: {
      "x-generate-time-ms": String(elapsed),
      "x-user-count": String(count),
      "x-split-via": "service-binding-rpc",
    },
  });
}
